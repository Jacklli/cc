#include "lex.h"
#include "keyword.h"

int Lexer::GetNextToken(void) {
    int tok;

    PrevCoord = TokenCoord;
    SkipWhiteSpace();
    TokenCoord.line = LINE; // line number in the *.i for C compiler
    TokenCoord.col  = (int)(CURSOR - LINEHEAD + 1);
    // use function pointer table to avoid a large switch statement.
    tok = (*Scanners[*CURSOR])();
    return tok;
}

void Lexer::BeginPeekToken(void) {
    PeekPoint = CURSOR;
    PeekValue = TokenValue;
    PeekCoord = TokenCoord;
}

void Lexer::EndPeekToken(void) {
    CURSOR = PeekPoint;
    TokenValue = PeekValue;
    TokenCoord = PeekCoord;
}

/**
 * Scans preprocessing directive which specify the line number and filename such as:
 * # line 6 "C:\\Program Files\\Visual Stduio 6\\VC6\\Include\\stdio.h" or
 * # 6 "/usr/include/stdio.h"
 * Ignores other preprocessing directive.
 */
 /*****************************************************
        hello.c --->  hello.i           (On Linux)

        hello.c
                Line1:  #include <stdio.h>
                Line2:  int f(int n){
        hello.i
                Line655:        # 2 "hello.c" 2
  *****************************************************/

void Lexer::ScanPPLine(void) {
    int line = 0;

    CURSOR++;
    while (*CURSOR == ' ' || *CURSOR == '\t') {
        CURSOR++;
    }
    // # 2 "hello.c" 2              on Linux
    if (IsDigit(*CURSOR)) {
        goto read_line;
    }
    // # line 6 "C:\\Program Files\\Visual Stduio 6\\VC6\\Include\\stdio.h"         on Windows
    else if (strncmp(CURSOR, "line", 4) == 0) {
        CURSOR += 4;
        while (*CURSOR == ' ' || *CURSOR == '\t') {
            CURSOR++;
        }

read_line:
        // line number
        while (IsDigit(*CURSOR)) {
            line = 10 * line + *CURSOR - '0';
            CURSOR++;
        }
        TokenCoord.ppline = line - 1;
        // skip white space
        while (*CURSOR == ' ' || *CURSOR == '\t') {
            CURSOR++;
        }
        //get the filename: "hello.c " --->  hello.c
        TokenCoord.filename = ++CURSOR;
        while (*CURSOR != '"' && !IS_EOF(CURSOR)&& *CURSOR != '\n') {
            CURSOR++;
        }
        TokenCoord.filename = InternName(TokenCoord.filename, (char *)CURSOR - TokenCoord.filename);
    }
    while (*CURSOR != '\n' && !IS_EOF(CURSOR)) {
        CURSOR++;
    }
}

void Lexer::SkipWhiteSpace(void) {
    int ch;

again:
    ch = *CURSOR;
    while (ch == '\t' || ch == '\v' || ch == '\f' || ch == ' ' ||
         ch == '\r' || ch == '\n' || ch == '/'  || ch == '#') {
        switch (ch) {
            case '\n':
                TokenCoord.ppline++;
                LINE++;
                LINEHEAD = ++CURSOR;
                break;

            case '#':       //  # 2 "hello.c"               *.i files               generated by preprocesser
                ScanPPLine();
                break;

            case '/':       // comments
                /**************************************************
                    C Style comment or C++ style comment
                    On Linux, 
                    In fact , all the comments have been eaten by preprocesser.
                    The UCL compiler won't encounter any comments.
                 ***************************************************/
                if (CURSOR[1] != '/' && CURSOR[1] != '*')
                    return;
                CURSOR++;
                if (*CURSOR == '/') {
                    CURSOR++;
                    while (*CURSOR != '\n' && !IS_EOF(CURSOR)) {
                        CURSOR++;
                    }
                }
                else {
                   CURSOR += 1;
                   while (CURSOR[0] != '*' || CURSOR[1] != '/') {
                       if (*CURSOR == '\n') {
                           TokenCoord.ppline++;
                           LINE++;
                       }
                       else if (IS_EOF(CURSOR)|| IS_EOF(&CURSOR[1])) {
                           Error(&TokenCoord, "Comment is not closed");
                           return;
                       }
                       CURSOR++;
                   }
                   CURSOR += 2;
                }
                break;

            default:
                CURSOR++;
                break;
        }
        ch = *CURSOR;
    }

    if (ExtraWhiteSpace != NULL) {
        char *p;
        // ignore the unknown strings, that is , ExtraWhiteSpace.
        FOR_EACH_ITEM(char*, p, ExtraWhiteSpace)
            if (strncmp(CURSOR, p, strlen(p)) == 0) {
                CURSOR += strlen(p);
                goto again;
            }
        ENDFOR
    }
}


